-- 서브쿼리 실습 문제
--문제1
--기술지원부에 속한 사람들의 사람의 이름,부서코드,급여를 출력하시오
--방법1.
SELECT EMP_NAME, DEPT_CODE, SALARY FROM EMPLOYEE
WHERE DEPT_CODE = ( SELECT DEPT_ID FROM DEPARTMENT WHERE DEPT_TITLE = '기술지원부');
--방법2.


--문제2
--기술지원부에 속한 사람들 중 가장 연봉이 높은 사람의 이름,부서코드,급여를 출력하시오
--기술지원부 연봉 맥스를 서브쿼리로 사용해보기
-- DEPT_TITLE = '기술지원부'
-- SALARY가 더 높은 사람이 없다. NOT EXISTS( SALARY > SALARY)
-- SALARY값이 맥스이다.'
SELECT EMP_NAME,DEPT_CODE,SALARY
FROM EMPLOYEE E1
WHERE DEPT_CODE = (SELECT DEPT_ID FROM DEPARTMENT WHERE DEPT_TITLE ='기술지원부')
      AND SALARY = (SELECT MAX(SALARY) FROM EMPLOYEE WHERE DEPT_CODE = 
                   (SELECT DEPT_ID FROM DEPARTMENT WHERE DEPT_TITLE ='기술지원부'));  
  --답안                 
SELECT *
FROM (SELECT EMP_NAME, DEPT_CODE, SALARY
        FROM EMPLOYEE
        WHERE DEPT_CODE 
            = (SELECT DEPT_ID FROM DEPARTMENT WHERE DEPT_TITLE ='기술지원부') 
                ORDER BY SALARY DESC)
WHERE ROWNUM = 1;        -- ROWNUM 컬럼을 만들지 않아도 사용할 수가 있다!             
       
            

SELECT MAX(SALARY) FROM EMPLOYEE E
JOIN DEPARTMENT D ON  E.DEPT_CODE = D.DEPT_ID
WHERE DEPT_TITLE ='기술지원부';  -- 이것을 서브쿼리로

SELECT EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY = (SELECT MAX(SALARY) FROM EMPLOYEE E
JOIN DEPARTMENT D ON  E.DEPT_CODE = D.DEPT_ID
WHERE DEPT_TITLE ='기술지원부') AND DEPT_CODE ='D8';
--이렇게 하면 다른 부서에 급여가 같은 사람이 있을 경우 같이 조회가 된다.
--WHERE에 AND DEPT_CODE='D8'은 추가하는 것은 불완전해 보임.

--상관쿼리를 사용한다면 어떻게 해야할까?
--부서이름을 JOIN이 아닌 서브쿼리로 사용하려면 어떻게 해야할까?

SELECT EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE E
WHERE NOT EXISTS ( SELECT 1 FROM EMPLOYEE M JOIN DEPARTMENT D ON M.DEPT_CODE = D.DEPT_ID
               WHERE DEPT_TITLE != '기술지원부' AND E.SALARY < M.SALARY );






--문제3
--매니저가 있는 사원중에 월급이 전체사원 평균을 넘고 
--사번,이름,매니저 이름,월급(만원단위부터)을 구하시오
 --* 단, JOIN을 이용하시오
 
 SELECT EMP_ID, EMP_NAME, 
       (SELECT EMP_NAME FROM EMPLOYEE E2 WHERE E1.MANAGER_ID = E2.EMP_ID)"매니저이름",
       SALARY
 FROM EMPLOYEE E1
 WHERE SALARY > (SELECT AVG(SALARY) FROM EMPLOYEE)
        AND MANAGER_ID IS NOT NULL;
        
--JOIN을 이용한다면 뭐랑 뭘 조인하지?

SELECT E1.EMP_ID, E1.EMP_NAME,A.EMP_NAME"매니저이름",SALARY/10000"월급(만원)"
FROM EMPLOYEE E1 JOIN (SELECT EMP_ID,EMP_NAME FROM EMPLOYEE E2)A ON A.EMP_ID = E1.MANAGER_ID
WHERE SALARY > (SELECT(AVG(SALARY)) FROM EMPLOYEE); -- 같은 테이블을 바로 조인하는 것이 가능하다.

SELECT EMP_NAME FROM EMPLOYEE E2;

--답안
SELECT 
    EMP.EMP_ID,
    EMP.EMP_NAME,
    MNG.EMP_NAME "매니저 이름",
    TRUNC(EMP.SALARY, -4) "급여(만원)"
FROM EMPLOYEE EMP
JOIN EMPLOYEE MNG ON (EMP.MANAGER_ID = MNG.EMP_ID)
WHERE EMP.MANAGER_ID IS NOT NULL 
AND EMP.SALARY > (SELECT AVG(SALARY) FROM EMPLOYEE);



--문제4
--부서 별 각 직급마다 급여 등급이 가장 높은 직원의 이름, 직급코드, 급여, 급여등급 조회
SELECT DEPT_CODE,EMP_NAME, JOB_CODE, SALARY,
        (SELECT MIN(SAL_LEVEL) FROM EMPLOYEE E2 WHERE
         E1.DEPT_CODE = E2.DEPT_CODE AND E1.JOB_CODE = E2.JOB_CODE )"급여등급"
FROM EMPLOYEE E1
ORDER BY 1 ASC;


--답안
SELECT
    E1.EMP_NAME,
    E1.JOB_CODE,
    E1.SALARY,
    E1.SAL_LEVEL
FROM EMPLOYEE E1
WHERE E1.SAL_LEVEL = (SELECT MIN(E2.SAL_LEVEL) FROM EMPLOYEE E2 
                        WHERE E1.JOB_CODE = E2.JOB_CODE) ORDER BY 4; -- 상관쿼리

--답안2
SELECT 
    E1.DEPT_CODE,
    E1.EMP_NAME,
    E1.JOB_CODE,
    E1.SAL_LEVEL,
    E1.SALARY
FROM EMPLOYEE E1
JOIN EMPLOYEE E2 ON E1.JOB_CODE = E2.JOB_CODE
ORDER BY 2;




SELECT EMP_NAME, JOB_CODE,SALARY,SAL_LEVEL
FROM EMPLOYEE E1
WHERE SAL_LEVEL IN( SELECT DEPT_CODE,JOB_CODE,MIN(E2.SAL_LEVEL) 
                    FROM EMPLOYEE E2
                    GROUP BY DEPT_CODE,JOB_CODE);
                
                    

SELECT DEPT_CODE,JOB_CODE,MIN(SAL_LEVEL)
FROM EMPLOYEE
GROUP BY DEPT_CODE,JOB_CODE;

SELECT EMP_NAME,JOB_CODE,SALARY,SAL_LEVEL
FROM EMPLOYEE E1
WHERE EXISTS( SELECT 1 FROM EMPLOYEE E2
              WHERE E1.DEPT_CODE = E2.DEPT_CODE AND E1.JOB_CODE = E2.JOB_CODE AND
                E1.SAL_LEVEL<E2.SAL_LEVEL);

SELECT DEPT_CODE,EMP_NAME,JOB_CODE,SALARY,SAL_LEVEL
FROM EMPLOYEE E1
WHERE EXISTS( SELECT 1 FROM EMPLOYEE E2
              WHERE E1.JOB_CODE = E2.JOB_CODE AND
                E1.SAL_LEVEL<E2.SAL_LEVEL
              GROUP BY E2.DEPT_CODE
                )
ORDER BY 1 ASC;



/*
SELECT DEPT_CODE,JOB_CODE,COUNT(*)
FROM EMPLOYEE
GROUP BY DEPT_CODE,JOB_CODE;
WHERE */

SELECT EMP_NAME, JOB_CODE, SALARY, SAL_LEVEL, DEPT_CODE
FROM EMPLOYEE E1
WHERE SAL_LEVEL = (SELECT MIN(E2.SAL_LEVEL) FROM EMPLOYEE E2 WHERE E1.JOB_CODE = E2.JOB_CODE);





--문제5
--부서별 평균 급여가 2200000 이상인 부서명, 평균 급여 조회
--단, 평균 급여는 소수점 버림

--풀이1) 조인과 그룹바이 사용
SELECT DEPT_CODE, DEPT_TITLE, FLOOR(AVG(SALARY))
FROM DEPARTMENT JOIN EMPLOYEE ON DEPT_ID = DEPT_CODE
GROUP BY DEPT_CODE,DEPT_TITLE
HAVING FLOOR(AVG(SALARY)) >= 2200000
ORDER BY 1;

--풀이2) 셀렉트와 웨어에 서브쿼리사용
SELECT DEPT_ID,DEPT_TITLE "부서명", (SELECT FLOOR(AVG(SALARY)) FROM EMPLOYEE WHERE DEPT_CODE = DEPT_ID)"평균급여"
FROM DEPARTMENT D 
WHERE  (SELECT FLOOR(AVG(SALARY)) FROM EMPLOYEE WHERE DEPT_CODE = DEPT_ID)>= 2200000;

--답안) 인라인뷰 사용
SELECT 
    DEPT_CODE,
    "평균SALARY",
    DEPT_TITLE "부서명"
FROM(
SELECT
    DEPT_CODE,
    FLOOR(AVG(SALARY)) "평균SALARY"
FROM EMPLOYEE
GROUP BY DEPT_CODE
HAVING FLOOR(AVG(SALARY)) >= 2200000)
JOIN DEPARTMENT ON DEPT_CODE = DEPT_ID
ORDER BY 1;



--문제6
--직급의 연봉 평균보다 적게 받는 여자사원의
--사원명,직급코드,부서코드,연봉을 이름 오름차순으로 조회하시오
--연봉 계산 => (급여+(급여*보너스))*12    
-- 사원명,직급명,부서명,연봉은 EMPLOYEE 테이블을 통해 출력이 가능함 
-- 직급별 연봉
SELECT EMP_NAME, JOB_CODE, DEPT_CODE,(SALARY+(SALARY*NVL(BONUS,0)))*12
FROM EMPLOYEE E1
WHERE SALARY < (SELECT AVG(SALARY) FROM EMPLOYEE E2 WHERE E1.JOB_CODE = E2.JOB_CODE)
AND SUBSTR(EMP_NO,8,1) = 2
ORDER BY 1 ASC;

--답안
SELECT
    AVG(SALARY*12)
FROM EMPLOYEE
GROUP BY JOB_CODE;
-- 여자사원들 및 여자사원들의 연봉, 직급코드 
SELECT SALARY*12, JOB_CODE
FROM EMPLOYEE
WHERE SUBSTR(EMP_NO,8,1) = 2;

SELECT EMP_NAME, JOB_CODE, DEPT_CODE, SALARY*12 "ANNUAL_SALARY"
FROM EMPLOYEE E
WHERE SUBSTR(EMP_NO,8,1) = 2
AND (SALARY*12) < (SELECT AVG(SALARY*12) FROM EMPLOYEE Y 
                                WHERE E.JOB_CODE = Y.JOB_CODE) -- 상관쿼리
ORDER BY 1 ASC;
    

--직급의 평균연봉 구하기 1) 그룹바이를 사용한다. 2) 상관쿼리를 사용한다.
--1)
SELECT DEPT_CODE, AVG(SALARY) FROM EMPLOYEE GROUP BY DEPT_CODE ORDER BY 1 ASC;
SELECT EMP_NAME,DEPT_CODE,JOB_CODE,(SELECT AVG(SALARY) FROM EMPLOYEE E2 WHERE E1.DEPT_CODE = E2.DEPT_CODE AND E1.JOB_CODE = E2.JOB_CODE)
FROM EMPLOYEE E1
ORDER BY 1 ASC;

