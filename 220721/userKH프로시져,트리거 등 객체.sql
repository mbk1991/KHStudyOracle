--PL/SQL과 관련된 오라클 객체
-- Function, Procedure, Cursor, Package, Trigger, Job,...

-- PL/SQL의 유형
-- PL/SQL 유형은 3가지가 있음, 익명블록(Anonymous Block), 프로시저(Procedure), 함수(Function)
-- 익명블록 : 이름 없는 블록이라 불리며 간단한 block 수행시 사용됨
-- 프로시저 : 지정된 특정처리를 실행하는 서브프로그램의 한 유형으로 단독으로 실행되거나
-- 다른 프로시저나 다른 툴 등에 의해 호출되어 실행됨
-- 함수 : Procedure와 수행되는 결과가 유사하나 값 반환 여부에 따라 차이가 있음
-- 함수는 반환값이 있음.

-- 프로시져는 일련의 작업절차를 정리해서 저장해 둔 것
-- 여러 SQL문을 묶어서 미리 정의해두고 하나의 요청으로 실행 할 수 있음
-- 자주 사용되는 복잡한 작업들을 간단하게 미리 만들어 두면 쉽게 사용이 가능함
-- 자바로 다 해결할 수 있는 부분임.

SET SERVEROUTPUT ON;

--1. Stored Procedure
--예제
CREATE TABLE EMP_DUP AS SELECT * FROM EMPLOYEE;
SELECT * FROM EMP_DUP;

--EMP_DUP의 데이터를 모두 삭제하는 프로시져 생성.
CREATE PROCEDURE DEL_ALL_EMP
IS
BEGIN
    DELETE FROM EMP_DUP;
    COMMIT;
END;
/

EXECUTE DEL_ALL_EMP;
SELECT * FROM EMP_DUP;  --깔끔하게 지워짐

SELECT * FROM USER_PROCEDURES;
--DEVELOPER GUI환경에서 확인하거나 CLI로 확인할 수 있다.
--프로시저의 소스를 확인하는 데이터 딕셔너리
SELECT * FROM  USER_SOURCE
WHERE NAME = 'DEL_ALL_EMP';

SELECT *FROM USER_SOURCE;

--예제2. 매개변수 있는 프로시져 만들기 -- 에러 찾기..
--0/0       PL/SQL: Compilation unit analysis terminated
--1/37      PLS-00201: identifier 'EMP_DUM.EMP_ID' must be declared
INSERT INTO EMP_DUP (SELECT * FROM EMPLOYEE); --데이터를 다시 넣어줌
SELECT * FROM EMP_DUP;
COMMIT;

CREATE PROCEDURE PROC_DEL_EMP_ID(
    P_EMP_ID  EMPLOYEE.EMP_ID%TYPE
)
IS
BEGIN
    DELETE FROM EMP_DUP WHERE EMP_ID = P_EMP_ID;
    COMMIT;
    DBMS_OUTPUT.PUT_LINE(P_EMP_ID || '번 사원을 삭제했습니다.');
END;
/

DROP PROCEDURE PROC_DEL_EMP_ID;

EXECUTE PROC_DEL_EMP_ID(&사원번호);


--예제3. 매개변수의 모드지정(IN,OUT,INOUT),바인드변수
--매개변수 IN: 데이터를 전달받을 때
--매개변수 OUT: 수행된 결과를 반환할 때
--매개변수INOUT: 데이터를 전달받고 수행된 결과를 반환할 때
--바인드 변수: 값을 받아 사용하는 변수

--셀렉트를 해주는 프로시저

CREATE PROCEDURE PROC_SELECT_EMP_ID(
    P_EMP_ID IN EMPLOYEE.EMP_ID%TYPE,
    P_EMP_NAME OUT EMPLOYEE.EMP_NAME%TYPE,
    P_SALARY OUT EMPLOYEE.SALARY%TYPE,
    P_BONUS OUT EMPLOYEE.BONUS%TYPE
)
IS
BEGIN
    SELECT EMP_NAME, SALARY, NVL(BONUS,0)
    INTO P_EMP_NAME, P_SALARY, P_BONUS
    FROM EMPLOYEE
    WHERE EMP_ID = P_EMP_ID;
END;
/
SELECT * FROM USER_PROCEDURES;

--바인드 변수 선언
--VAR [LIABLE] : 바인드변수와 매개변수의 자료형은 반드시 같아야함
--주석달기 조심

VAR B_EMP_NAME VARCHAR2(30);
VAR B_SALARY NUMBER;
VAR B_BONUS NUMBER;

EXEC PROC_SELECT_EMP_ID('202',:B_EMP_NAME,:B_SALARY,:B_BONUS);

PRINT B_EMP_NAME;
PRINT B_SALARY;
PRINT B_BONUS;

--모아보기
VAR RESULT VARCHAR2(100);
EXEC :RESULT := (:B_EMP_NAME ||' '|| :B_SALARY ||' '|| :B_BONUS);
PRINT RESULT;

--프로시저 실행과 동시에 모든 바인드 변수를 출력
--사용된 변수를 실행하고 출력함
SET AUTOPRINT ON;


-- 실습1) JOB테이블에 INSERT를 할 때 같은 직급코드가 있으면 UPDATE를 수행하고 없으면
-- 그대로 INSERT를 하는 PROCEDURE를 작성하시오.
-- 1단계. JOB테이블에 INSERT하는 프로시저를 작성
-- 2단계. 요구사항에 맞게 조건문을 추가하여 변경

CREATE TABLE JOB_COPY AS SELECT * FROM JOB;
SELECT * FROM JOB_COPY;

CREATE OR REPLACE PROCEDURE PROC_INSERT_JOB_CODE (
    P_JOB_CODE IN JOB_COPY.JOB_CODE%TYPE,
    P_JOB_NAME IN JOB_COPY.JOB_NAME%TYPE
)
IS
    V_CNT NUMBER := 0;
BEGIN
    SELECT COUNT(*)
    INTO V_CNT
    FROM JOB_COPY
    WHERE JOB_CODE = P_JOB_CODE;

    IF(V_CNT > 0)
    THEN
        UPDATE JOB_COPY SET JOB_NAME = P_JOB_NAME
        WHERE JOB_CODE = P_JOB_CODE;
    ELSE
        INSERT INTO JOB_COPY VALUES(P_JOB_CODE, P_JOB_NAME);
    END IF;
    COMMIT;
END;
/

--강사님 코드
CREATE OR REPLACE PROCEDURE PROC_ADD_JOB_DUP(
    P_JOB_CODE IN JOB_DUP.JOB_CODE%TYPE,
    P_JOB_NAME IN JOB_DUP.JOB_NAME%TYPE
)
IS
    V_CNT NUMBER := 0;
BEGIN
    SELECT COUNT(*)
    INTO V_CNT
    FROM JOB_DUP
    WHERE JOB_CODE = P_JOB_CODE;
    
    IF(V_CNT > 0)
    THEN 
        UPDATE JOB_DUP SET JOB_NAME = P_JOB_NAME
        WHERE JOB_CODE = P_JOB_CODE;
    ELSE
        INSERT INTO JOB_DUP VALUES(P_JOB_CODE, P_JOB_NAME);
    END IF;
    COMMIT;
END;
/





SELECT * FROM USER_PROCEDURES;
DROP PROCEDURE PROC_INSERT_JOB_CODE;

EXECUTE PROC_INSERT_JOB_CODE('J9','이사장');
SELECT * FROM JOB_COPY;

ALTER TABLE JOB_COPY 
ADD CONSTRAINT PK_JOB_CODE PRIMARY KEY(JOB_CODE);

ALTER TABLE JOB_COPY ADD (TEST_COL NUMBER CHECK(TEST_COL IN(1,2));
ALTER TABLE JOB_COPY DROP (TEST_COL);

ALTER TABLE JOB_COPY 
MODIFY CONSTRAINT PK_JOB_CODE FOREIGN KEY (JOB_CODE);
ALTER TABLE JOB_COPY DROP CONSTRAINT SYS_C007265;


-- 2. FUNCTION
-->리턴값이 반드시 존재하는 객체
/*
    CREATE OR REPLACE FUNCTION 함수이름(매개변수명 자료형,...)
    RETURN 자료형
    IS
        지역변수선언;
    BEGIN
        실행문
        RETURN 데이터;
    END;
    /
*/
--문자형 사용시  매개변수 리턴의 데이터타입 크기를 지정하면 에러가 난다.

--예제, 헤드폰 씌우기
CREATE OR REPLACE FUNCTION MAKE_HEADPHONE(P_STR VARCHAR2)
RETURN VARCHAR2 
--리턴타입 설정
IS
    MADEHEADPHONE VARCHAR2(32767);
BEGIN
    MADEHEADPHONE := 'd'||P_STR||'b';
    RETURN MADEHEADPHONE;
END;
/
VAR RESULT VARCHAR2;

EXECUTE :RESULT := MAKE_HEADPHONE('^-^');

--예제1. 사번을 입력 받아 해당 사원의 연봉을 계산하여 리턴하는 저장함수를 만들어 출력하시오
CREATE OR REPLACE FUNCTION FN_BONUS_CALC(
    P_EMP_ID EMPLOYEE.EMP_ID%TYPE
)
RETURN NUMBER
IS
    V_SAL EMPLOYEE.SALARY%TYPE;
    V_BONUS EMPLOYEE.BONUS%TYPE;
BEGIN
    SELECT SALARY, NVL(BONUS,0)
    INTO V_SAL, V_BONUS
    FROM EMPLOYEE
    WHERE EMP_ID = P_EMP_ID;
    RETURN (V_SAL * 12 + V_SAL * V_BONUS);
END;
/


VAR VAR_CALC NUMBER;
EXEC : VAR_CALC := FN_BONUS_CALC('204');

--@실습문제
--1.사원번호를 입력받아서 성별을 리턴하는 저장함수 FN_GET_GENDER를 생성하고, 실행하세요.
CREATE OR REPLACE FUNCTION FN_GET_GENDER ( F_EMP_ID EMPLOYEE.EMP_ID%TYPE)
RETURN VARCHAR2
IS 
    V_SSN VARCHAR2(32767);
BEGIN
    SELECT CASE SUBSTR(EMP_NO,8,1) WHEN '1' THEN '남' WHEN '2' THEN '여' END "성별"
    INTO V_SSN
    FROM EMPLOYEE
    WHERE EMP_ID = F_EMP_ID;

    RETURN V_SSN;
END;
/

VAR V_GENDER VARCHAR2;
EXEC :V_GENDER := FN_GET_GENDER('203');

--FUNCTION 을 SQL에서 실행할 수 있다!
SELECT EMP_ID, EMP_NAME, FN_GET_GENDER(EMP_ID)
FROM EMPLOYEE;



--2. 사용자로부터 입력받은 사원명으로 검색하여 해당사원의 직급명을 얻어 오는 저장함수
-- FN_GET_JOB_NAME를 작성하세요. (해당사원이 없다면 '해당사원없음' 출력)

CREATE OR REPLACE FUNCTION FN_GET_JOB_NAME (P_EMP_NAME EMPLOYEE.EMP_NAME%TYPE)
RETURN VARCHAR2
IS
 ANSWER VARCHAR2(32767);
BEGIN
    SELECT JOB_NAME
    INTO ANSWER
    FROM EMPLOYEE E JOIN JOB J USING(JOB_CODE)
    WHERE E.EMP_NAME = P_EMP_NAME;
    
    RETURN ANSWER;
END;
/

VAR V_JOB_NAME VARCHAR2;
EXECUTE :V_JOB_NAME := FN_GET_JOB_NAME('하이유');



--3. 사원에게 특별상여금(보너스)를 지급하려고 하는데, 입사일기준으로 차등 지급하려 한다.
-- 입사일기준 10년이상이면 150%, 3년이상 10년미만이면 125%, 3년미만이면 50%를 지급함.
-- 저장함수명 : FN_BONUS_CALC, FN_GET_WORKING_DAYS(HIRE_DATE)
-- 조회컬럼 : 사번, 사원명, 입사일, 근무기간(~년 ~개월), 보너스금액 매개변수가 사번임.

CREATE OR REPLACE FUNCTION FN_BONUS_CALC(
    P_EMP_ID EMPLOYEE.EMP_ID%TYPE
)
RETURN NUMBER
IS
 V_ID VARCHAR2(30);
 V_NAME VARCHAR2(30);
 V_DATE DATE;
 V_WORKINGDAY
BEGIN
    SELECT EMP_ID, EMP_NAME, HIRE_DATE, FN_GET_WORKING_DAYS(HIRE_DATE)
    INTO V_ID, V_NAME, V_DATE, V_WORKINGDAY
    FROM EMPLOYEE
    WHERE EMP_ID = P_EMP_ID;
    
    -- 요구사항 조건문
    
    RETURN
END;
/


CREATE OR REPLACE FUNCTION FN_GET_WORKING_DAYS(P_HIRE_DATE EMPLOYEE.HIRE_DATE%TYPE)
RETURN NUMBER
IS
    
    COUNTYEAR NUMBER;
BEGIN
    SELECT (SYSDATE -  HIRE_DATE)
    INTO COUNTYEAR
    FROM EMPLOYEE
    WHERE HIRE_DATE = P_HIRE_DATE;
    RETURN COUNTYEAR;
END;
/




--@실습문제
--기존부서테이블의 DEPT_ID, DEPT_TITLE만 복제한 DEPT_COPY를 생성한다.
--DEPT_ID 컬럼 PK추가. DEPT_ID 컬럼 확장 CHAR(3)
--DEPT_COPY를 관리하는 프로시져 PROC_MAN_DEPT_COPY를 생성한다.
-- 첫번째 인자로 동장FLAG값 UPDATE/DELETE를 받는다.
-- UPDATE시, 데이터가 존재하지 않으면 INSERT, 데이터가 존재하면, UPDATE
-- DELETE시, 해당부서에 사원이 존재하는지를 검사해서, 존재하면, 경고메세지와 함께 실행취소함. 그렇지 않으면, 삭제.
-- 프로시저의 매개변수에 기본값을 지정하면, 생략가능함.

CREATE TABLE DEPT_COPY AS SELECT DEPT_ID, DEPT_TITLE FROM DEPARTMENT;
SELECT * FROM DEPT_COPY;
DESC DEPT_COPY;
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME ='DEPT_COPY';
ALTER TABLE DEPT_COPY ADD CONSTRAINT PK_DEPT_ID PRIMARY KEY(DEPT_ID);
ALTER TABLE DEPT_COPY  MODIFY (DEPT_ID CHAR(3));

CREATE OR REPLACE PROCEDURE PROC_MAN_DEPT_COPY


--3. Trigger
-- 트리거의 사전적 의미: 방아쇠 , 연쇄반응
--> 특정 이벤트나 DDL, DML문장이 실행되었을 때
--자동적으로  어떤 일련의 동작(Operation), 처리가 수행되도록 하는 데이타베이스 객체의 하나

-- 1). 회원 탈퇴가 이루어질 경우 (EMPLOYEE에서 DELETE가 되었을 때)
--    해당 회원정보가 다른 테이블에 저장이 필요한 경우( 자동적으로 INSERT가 되도록)
--    탈퇴회원 정보를 따로 분리하여 관리할 때
-- 2) 데이터 변경이 있을 때 (DEPARTMENT에서 UPDATE가 되었을 때)
--    해당 정보들을 저장하는 경우(LOG에서 INSERT가 됨)

/*
    CREATE TRIGGER 트리거이름
        BEFORE(OR AFTER)
        UPDATE(OR DELETE OR INSERT) ON  테이블명
        [FOR EACH ROW]
    BEGIN
        (실행문)
    END;
    /
*/

-- # 트리거의 속성
/*
    1.BEFORE: 데이터 처리가 실행되기 전 수행
    2.AFTER: 데이터 처리가 실행된 후 수행
    3.FOR EACH ROW: 데이터 처리 시 건별로(행별로) 실행,행레벨 트리거
    4.OLD.컬럼명 : 바인드변수, DELETE삭제 시 삭제한 정보가 있음
    5.NEW.컬럼명 : 바인드변수, INSERT추가 시 저장할 정보가 있음 UPDATE는 둘 다
*/
CREATE TABLE EMP_TEMP AS SELECT EMP_ID,EMP_NAME FROM EMPLOYEE;


--예제1. 사원 테이블에 새로운 데이터가 들어오면"신입사원이 입사하였습니다"를 출력하기.
CREATE OR REPLACE TRIGGER TRG_EMP_NEW
    AFTER
    INSERT ON EMP_TEMP
    FOR EACH ROW
BEGIN
    DBMS_OUTPUT.PUT_LINE('신입 사원이 입사했습니다.');
END;
/
DROP TRIGGER TRG_EMP_NEW;

INSERT INTO EMP_TEMP VALUES('230','홍길동');
COMMIT;

ALTER TABLE EMP_TEMP ADD (SALARY NUMBER);
SELECT * FROM EMP_TEMP;
INSERT INTO EMP_TEMP SELECT SALARY FROM EMPLOYEE;

--## 의사레코드 OLD, NEW
-- FOR EACH ROW를 사용해야 함
-- 1. INSERT 트리거 : OLD -> NULL, NEW -> 데이터변경후의 레코드
-- 2. UPDATE 트리거 : OLD -> 데이터변경전 레코드, NEW -> 데이터변경후의 레코드
-- 3. DELETE 트리거 : OLD -> 데이터변경전 레코드, NEW -> NULL
CREATE TABLE EMP_SAL_TBL
AS SELECT * FROM EMPLOYEE;

-- 예제2. 급여변경 전후정보를 화면에 출력하는 트리거를 생성해보자
CREATE OR REPLACE TRIGGER TRG_EMP_SAL
    BEFORE
    UPDATE ON EMP_SAL_TBL
    FOR EACH ROW
BEGIN
    DBMS_OUTPUT.PUT_LINE('변경 전 :' || :OLD.SALARY);
    DBMS_OUTPUT.PUT_LINE('변경 후 :' || :NEW.SALARY);
END;
/

SELECT * FROM USER_TRIGGERS;
UPDATE EMP_SAL_TBL SET SALARY = SALARY*2 WHERE EMP_ID = '205';
COMMIT;

--예제3. 제품 테이블을 생성하고 제품 입고 시 상품재고 테이블의 수치를 관리해보자
--   트리거를 사용해 재고가 입출고시 자동으로 재고가 입력되도록 해보자.
--1. 제품테이블 PRODUCT 
--2. 제품 입출고 PRODUCT_IO
CREATE TABLE PRODUCT(
  PCODE NUMBER PRIMARY KEY,
  PNAME VARCHAR2(30),
  BRAND VARCHAR2(30),
  PRICE NUMBER,
  STOCK NUMBER DEFAULT 0
);

CREATE TABLE PRODUCT_IO(
  IOCODE NUMBER PRIMARY KEY,
  PCODE NUMBER,
  PDATE DATE,
  AMOUNT NUMBER,
  STATUS VARCHAR2(10) CHECK (STATUS IN ('입고', '출고')),
  CONSTRAINT FK_PRODUCT_IO FOREIGN KEY (PCODE) REFERENCES PRODUCT(PCODE)
);

--SEQUENCE 생성
CREATE SEQUENCE SEQ_PRODUCT_PCODE
START WITH 1
INCREMENT BY 1
NOMAXVALUE
NOMINVALUE
NOCYCLE
NOCACHE;

CREATE SEQUENCE SEQ_PRODUCTIO_IOCODE
START WITH 1
INCREMENT BY 1
NOMAXVALUE
NOMINVALUE
NOCYCLE
NOCACHE;

SELECT * FROM PRODUCT;

INSERT INTO PRODUCT
VALUES (SEQ_PRODUCT_PCODE.NEXTVAL,'갤럭시폴드4','삼성','2400000',DEFAULT);
INSERT INTO PRODUCT
VALUES (SEQ_PRODUCT_PCODE.NEXTVAL,'아이폰14','애플','2000000',DEFAULT);
INSERT INTO PRODUCT
VALUES (SEQ_PRODUCT_PCODE.NEXTVAL,'픽셀','샤오미','500000',DEFAULT);
COMMIT;
--트리거 생성
--입고, 출고될 때 PRODUCT 테이블에 STOCK값이 업데이트가 되어야함
CREATE OR REPLACE TRIGGER TRG_PRODUCT_STOCK
    AFTER
    INSERT ON PRODUCT_IO
    FOR EACH ROW
BEGIN
    IF:NEW.STATUS = '입고' 
    THEN
       UPDATE PRODUCT
       SET STOCK = STOCK + :NEW.AMOUNT;
       WHERE PRODUCT.PCODE = :NEW.PCODE;
    ELSE
        UPDATE PRODUCT
        SET STOCK = STOCK - :NEW.AMOUNT;
        WHERE PRODUCT.PCODE = :NEW.PCODE;
END;
/


CREATE OR REPLACE TRIGGER TRG_PRODUCT_STOCK
    AFTER
    INSERT ON PRODUCT_IO
    FOR EACH ROW
BEGIN
    IF :NEW.STATUS = '입고'
    THEN UPDATE PRODUCT SET STOCK = STOCK + :NEW.AMOUNT WHERE PCODE = :NEW.PCODE;
    ELSE UPDATE PRODUCT SET STOCK = STOCK - :NEW.AMOUNT WHERE PCODE = :NEW.PCODE;
    END IF;
END;
/

INSERT INTO PRODUCT_IO VALUES(SEQ_PRODUCTIO_IOCODE.NEXTVAL, 1, SYSDATE,5, '입고');
INSERT INTO PRODUCT_IO VALUES(SEQ_PRODUCTIO_IOCODE.NEXTVAL, 2, SYSDATE,10, '입고');
INSERT INTO PRODUCT_IO VALUES(SEQ_PRODUCTIO_IOCODE.NEXTVAL, 3, SYSDATE,3, '입고');
INSERT INTO PRODUCT_IO VALUES(SEQ_PRODUCTIO_IOCODE.NEXTVAL, 1, SYSDATE,3, '출고');
INSERT INTO PRODUCT_IO VALUES(SEQ_PRODUCTIO_IOCODE.NEXTVAL, 2, SYSDATE,7, '출고');
ROLLBACK;

SELECT * FROM PRODUCT_IO;
SELECT * FROM PRODUCT;
--나는 인서트만 하는데 재고가 관리가 되는 것!
--트리거를 생성한 후에는 PRODUCT_IO테이블에 입고를 하면 STOCK+1하고
--출고를 하면 STOCK-1이 되도록 동작

--@실습문제
--1. EMPLOYEE테이블의 퇴사자관리를 별도의 테이블 TBL_EMP_QUIT에서 하려고 한다.
--다음과 같이 TBL_EMP_JOIN, TBL_EMP_QUIT테이블을 생성하고, TBL_EMP_JOIN에서 DELETE시 자동으로 퇴사자 데이터가 TBL_EMP_QUIT에 INSERT되도록 트리거를 생성하라.

--TBL_EMP_JOIN 테이블 생성 : QUIT_DATE, QUIT_YN 제외
--2. 사원변경내역을 기록하는 emp_log테이블을 생성하고, 사원테이블의 insert, update가 있을 때마다 신규데이터를 기록하는 트리거를 생성하라.
--로그테이블명 emp_log : 컬럼 log_no(시퀀스객체로부터 채번함. pk), log_date(기본값 sysdate, not null), emp테이블의 모든 컬럼
--트리거명 trg_emp_log


SELECT * FROM ROLE_SYS_PRIVS WHERE ROLE='DBA';